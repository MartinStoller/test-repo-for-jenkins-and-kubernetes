UML Use Case Diagram (https://www.youtube.com/watch?v=zid-MVo7M-E):

Done for free with Lucidchart. Admin, bookkeeper and employee are all primary actors (-> left of the App), since they
take primary actions. There are no secondary actors (-> to the right of the App), which react to these actions.
Careful: The Database does not count as a secondary (or any) actor!
_______________________________________________________________________________________________________________________
Abstract Classes and methods
    Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).
    Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).
    // CAREFUL: Dont set things to private, because then childclasses can´t access it - set to protected instead
_______________________________________________________________________________________________________________________
What is an Interface?
An interface in the Java programming language is an abstract type that is used to specify a behavior that classes must
implement. They are similar to protocols. ... A class that implements an interface must implement all of the non-default
methods described in the interface, or be an abstract class.
_______________________________________________________________________________________________________________________
May to one, one to many, many to many
https://www.youtube.com/watch?v=f5bdUjEIbrg
propertie file muss auf "updatee" sein hierfür.
_______________________________________________________________________________________________________________________
Conditional Validations
https://stackoverflow.com/questions/54638255/spring-boot-validation-one-from-two-not-null   (both answers!)
_______________________________________________________________________________________________________________________
Authorization based on rolls:
https://www.codejava.net/frameworks/spring-boot/spring-boot-security-role-based-authorization-tutorial
https://www.youtube.com/watch?v=i21h6ThUiWc&t=5s
_______________________________________________________________________________________________________________________
Automated Emails:
https://www.youtube.com/watch?v=QwQuro7ekvc
https://www.baeldung.com/spring-email
https://stackoverflow.com/questions/43142137/sending-email-from-spring-boot-application-using-gmail
writing tests for email sending: https://www.youtube.com/watch?v=MOODnDflO-M
_______________________________________________________________________________________________________________________
Log-in:
i simplemented by MyUsderDetails class, which needs to extend Userdetails.class. Whatever the "ispassword()" function
returns will be recognized as the password. Moreover it allows for easy implementation of the "frozen" boolean via the
"isenabled()" function
_______________________________________________________________________________________________________________________
Patchmapping vs Putmapping:
In Patchmapping the Object we modify is maintained and we only change the information we pass to the Object. All other
Information stays. In Putmapping the entire Object is exchanged -> we need to pass all the information - not only the
new. All not passed information is lost.
https://stackoverflow.com/questions/28459418/use-of-put-vs-patch-methods-in-rest-api-real-life-scenarios
The convention is as follows: The URI of a patchmapping leads to the Resource which should be patched -> if we want to
patch the name of a Car-Object the URI would be sth like PATCH"api/cars" and NOT sth like PATCH"api/cars/name".
Thats because Putmapping is used to replace the entire resource, the URI is pointing to -> if we want to change the name
of a car.Object via Put-Mapping the URI would be sth like PUT"api/cars/name". Technically, both patch and put mapping
work with both URIs of course, but that´s the convention how they are supposed to be used in a RESTful way.
_______________________________________________________________________________________________________________________
URI vs URL
Die beiden Begriffe URI und URL werden oft verwechselt, weil sie ziemlich eng verwandt sind. Ein URI kann beispielsweise
ein Name, ein Locator oder beides für eine Online-Ressource sein, bei der eine URL nur der Locator ist. URLs sind eine
Teilmenge von URIs. Das heißt, alle URLs sind also auch URIs.
_______________________________________________________________________________________________________________________
Some more Conventions I learned about:
Postmethods are not void but return the generated resource as well as the HTTP status 201Created (vgl Post in
TimeTableDayController)
_______________________________________________________________________________________________________________________
Tricky errors which oocrued:
"GenerationTarget encountered exception accepting command : Error executing DDL "alter...""
-> Solution: turn DB  from "create-drop" to update once (after running it like that once i can change it back to create-drop)
_______________________________________________________________________________________________________________________
Cascade Types: https://www.baeldung.com/jpa-cascade-types
Entity relationships often depend on the existence of another entity, for example the Person–Address relationship.
Without the Person, the Address entity doesn't have any meaning of its own.
When we delete the Person entity, our Address entity should also get deleted.
Cascading is the way to achieve this. When we perform some action on the target entity, the same action will be applied to the associated entity.

THERE ARE THE FOLLOWING TYPES:
CascadeType.ALL: propagates all operations from a parent to a child entity.

CascadeType.PERSIST: propagates the persist operation from a parent to a child entity: When we save the person entity,
the address entity will also get saved.

CascadeType.MERGE: propagates the merge operation from a parent to a child entity: copies the state of the given object
onto the persistent object with the same identifier. (Merges the data in the table with the Data in the Objects)
(Stackoverflow: MERGE means something complex that approximates "save" but is more like "push this detached entity back
 into managed status and save its state changes"

CascadeType.REMOVE/DELETE: propagates the remove operation from parent to child entity. -> If we delete TimeTableDay,
the employee linked to that day gets deleted from the DB as well.

CascadeType.REFRESH:  In some cases, we may change an instance after persisting in the database, but later we need to undo those changes.
In that kind of scenario, this may be useful. When we use Cascade Type REFRESH, the child entity
also gets reloaded from the database whenever the parent entity is refreshed.

CascadeType.REPLICATE: replicate both the parent and the child entities. The replicate operation allows you to
synchronize entities coming from different sources of data.
(no idea what that means)

CascadeType.SAVE_UPDATE: propagates the same operation to the associated child entity. It's useful when we use
Hibernate-specific operations like save, update and saveOrUpdate.

CascadeType.LOCK: reattaches the entity and its associated child entity with the persistent context again. -> reverses DETACH

CascadeType.DETACH: the child entity will also get removed from the persistent context.
In Hibernate CascadeType.DETACH plays the role when more than one entity is associated to each other.
CascadeType.DETACH cascades the detach operation to all associated entities detach from hibernate session.
If one entity is detached, other associated entities will also be detached if CascadeType.DETACH is annotated.
For example if the entity Country is associated with State and we are detaching entity, both the entities Country and
State will be detached from current session of hibernate. In Hibernate we need to call detach() method to detach the entity.

Detached entity objects are objects in a special state in which they are not managed by any EntityManager but still
represent objects in the database. Compared to managed entity objects, detached objects are limited in functionality.
Detached objects are useful in situations in which an EntityManager is not available and for transferring objects between different EntityManager instances.
Marking a reference field with CascadeType.DETACH (or CascadeType.ALL, which includes DETACH) indicates that detach operations should be cascaded automatically to entity objects that are referenced by that field
Only Hibernate supports replicate and saveOrUpdate. While replicate is useful for some very specific scenarios (when the
 exact entity state needs to be mirrored between two distinct DataSources), the persist and merge combo is always a better alternative than the native saveOrUpdate operation.
OVERVIEW OVER SYNTAX and generally good article: https://vladmihalcea.com/a-beginners-guide-to-jpa-and-hibernate-cascade-types/
